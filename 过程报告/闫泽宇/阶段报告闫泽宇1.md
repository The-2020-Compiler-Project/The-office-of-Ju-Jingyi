## 阶段报告1

####       闫泽宇-20184406-计算机1807（语义分析）



#### 1.文法

#### 2.四元式设计

#### 3.符号表设计

#### 4.翻译文法及编译器设计







##### 1.文法

##### （总）：

<程序> → <主函数> | <主函数> <声明>

<主函数> → <类型标识符> <声明>|<类型标识符> <声明> <复合语句>

<声明> → <定义>|<定义><声明>

<定义> → <类型标识符> <数据声明;>|<类型标识符> <函数声明> <复合语句>|<类型标识符> <函数声明;> 

<标识符类型> → <void> | <char> | <int> | <float>

<数据声明> → <标识符> | <数据声明[ ]> | <数据声明[常量表达式]> | <数据声明 , 标识符>|<数据声明=初始化程序>

<函数声明> → <标识符（参数列表）> | <标识符（）> 

<常量表达式> → <条件表达式>

<参数列表> → <参数声明> | <参数列表 ,参数声明>

<参数声明> → <说明符声明><标识符>

<复合语句> → <{ }> | <{ 语句列表 }> | <{ <声明列表> <语句列表> }>

<声明列表> → <定义> | <定义><声明列表>

<初始化程序> → <表达式> 

<语句列表> → <语句> | <语句列表> <语句>

<语句> → <复合语句> | <表达式语句> | <选择语句> |<跳转语句>

<表达式语句> → <表达式;>

<选择语句> → < IF（表达式）语句> | < IF（表达式）语句 > < ELSE 语句>

<跳转语句> → <continue;> |<breack;> | <return;> | <return 表达式; >

<表达式> → <赋值表达式> | <表达式, 赋值表达式>

<赋值表达式> → <条件表达式> | <一元表达式> <赋值操作符> <赋值表达式>

<条件表达式> → <逻辑‘或’表达式> | <逻辑‘或’表达式？> <表达式:> <条件表达式>

<逻辑‘或’表达式> → <逻辑‘与’表达式> | <逻辑‘或’表达式> <‘或’运算> <逻辑‘与’表达式>

<逻辑‘与’表达式> → <逻辑‘或’表达式> | <逻辑‘与’表达式> <‘与’运算> <逻辑‘或’表达式>

<或运算表达式> → <异或表达式> | <或运算表达式‘|’ 异或表达式>

<异或表达式> → <与表达式> | <异或表达式 ^ 与表达式>

<与表达式> → <相等表达式> | <与表达式 & 相等表达式>

<相等表达式>→ <关系表达式> | <相等表达式> <等于运算> <关系表达式> | <相等表达式> <不等于运算> <关系表达式>

<关系表达式> → <替换表达式> | <关系表达式 < 替换表达式> | <关系表达式 > 替换表达式> | <关系表达式<=替换表达式> | <关系表达式>=替换表达式>

<替换表达式> → <加法表达式> | <替换表达式> <左运算> <加法表达式> | <替换表达式> <右运算> <加法表达式>

<加法表达式> → <乘法表达式> | <加法表达式 + 乘法表达式> | <加法表达式 - 乘法表达式>

<乘法表达式> → <强制转换表达式> | <乘法表达式 * 强制转换表达式> | <乘法表达式 / 强制转换表达式> | <乘法表达式 % 强制转换表达式>

<强制转换表达式> → <一元表达式> | <（类型名称）强制转换表达式>

<一元表达式> → <后缀表达式> | <加一运算> <一元表达式> | <减一运算> <一元表达式> | <一元运算符> <强制转换表达式> | <结构体变量> <一元表达式> | <结构体变量（类型名称）>

<后缀表达式> → <基本表达式> | <后缀表达式 [ 表达式 ]> | <后缀表达式（）> | <后缀表达式（参数表达式列表）> | <后缀表达式> <指针运算> <标识符> | <后缀表达式> <加一运算> | <后缀表达式> <减一运算>

<基本表达式> → <标识符> | <常量> | <字符串> | <（表达式）>

<参数表达式列表> → <参数表达式> | <参数表达式列表 , 参数表达式>

<一元运算符> → <&> | <*> | <+> |<-> | <~> | <!>

< 赋值运算符> → <=> | <乘法赋值> | <除法赋值> | <求余赋值> | <加法赋值> | <减法赋值> | <左赋值> | <右赋值> | <与赋值> | <异或赋值> | <或赋值>

 

#####  精简后：

<程序> → <主函数>

<主函数> → <类型标识符> <声明>|<类型标识符> <声明> <复合语句>

<声明> → <定义>|<定义><声明>

<定义> → <类型标识符> <数据声明;>|<类型标识符> <函数声明> <复合语句>|<类型标识符> <函数声明;> 

<标识符类型> → <void> | <char> | <int> | <float>

<数据声明> → <标识符> | <数据声明[ ]> | <数据声明[常量表达式]> | <数据声明 , 标识符>|<数据声明=初始化程序>

<函数声明> → <标识符（参数列表）> | <标识符（）> 

<常量表达式> → <条件表达式>

<参数列表> → <参数声明> | <参数列表 ,参数声明>

<参数声明> → <标志符类型><标识符>

<复合语句> → <{ }> | <{ 语句列表 }> | <{ <声明列表> <语句列表> }>

<初始化程序> → <表达式> 

<语句列表> → <语句> | <语句列表> <语句>

<语句> → <复合语句> |

<表达式> → <赋值表达式> 

<赋值表达式> → <一元表达式> <=> <加法表达式>

<加法表达式> → <乘法表达式> | <加法表达式 + 乘法表达式> | <加法表达式 - 乘法表达式>

<乘法表达式> → <一元表达式> | <乘法表达式 * 一元表达式> | <乘法表达式 / 一元表达式> | <乘法表达式 % 一元表达式>

<一元表达式> → <后缀表达式> 

<后缀表达式> → <基本表达式> | <后缀表达式 [ 表达式 ]> | <后缀表达式（）> | <后缀表达式（参数表达式列表）> 

<基本表达式> → <标识符> | <常量> | <字符串> | <（表达式）>

<参数表达式列表> → <参数表达式> | <参数表达式列表 , 参数表达式>

<参数表达式> → <加法表达式>

##### 2.四元式设计：

c++源码

```c++
typedef struct
{
	char c;
	string s;
	int i;
	float f;
}DATA;
typedef struct
{
	string s1;
	DATA d1;//第一项
	DATA d2;//第二项
	DATA d3;//结果项
}QUAT;
vector<QUAT>quat;
```



（1）赋值语句  ：  v = E 

quat(E),

        q(:= res(E) _ v )

（2）跳转语句 ：    continue  .......

         （co _ _ i） i指向前面一四元式

 break    （br _ _ i） i指向后方一四元式

           .....

 return   (re _ _ _) 

 <return 表达式; >  (re _ _ res(表达式))

（3）条件语句  ：  S ->if（E）S1[ else S2 ]

[![Nv2uE4.png](https://s1.ax1x.com/2020/07/04/Nv2uE4.png)](https://imgchr.com/i/Nv2uE4)





#### 3.符号表设计

（1）设计图：

[![Nv2La4.png](https://s1.ax1x.com/2020/07/04/Nv2La4.png)](https://imgchr.com/i/Nv2La4)

（2）c++源码：

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;

typedef struct
{
	char TVAL;
	struct Anifl* TPOINT;
}Tapel;//类型表一项
vector<Tapel>TAPEL;//类型表
typedef struct Ainfl
{
	int LOW;
	int UP;
	Tapel* CTP;
	int CLEN;
}Ainfl;//数组表一项
vector<Ainfl>AINFL;//数组表

typedef struct
{
	int LEVEL;
	int OFF;
	int FN;
	//PARAM形参表
	long int ENTRY;
}Pfinfl;//函数表一项;
typedef struct
{
	string NAME;
	Tapel* TYP;
	string CAT;
	union Addr* ADDR;//相对地址
}vf;//形参表一项
vector<vf>VF;//形参表
vector<Pfinfl>PFINFL;//函数表

typedef struct Consl
{
	string s;
	char c;
	int i;
	float f;
}Consl;//常量表一项
vector<Consl>CONSL;//常量表
vector<int>LEN;//长度表
typedef union Addr
{
	Pfinfl* p;
	Consl* c;
	int* i;
	//活动记录
}Addr;

typedef struct
{
	string NAME;
	Tapel* TYP;
	string CAT;
	Addr* ADDR;//ADDR
}Synbl;//符号表的一项

vector<Synbl>SYNBL;//符号表主表
```

##### 4.翻译文法设计

自顶向下使用递归子程序方法

在以下语句中插入语义动作：

1.<数据声明> →<数据声明 {push(数据声明)} =初始化程序 {ASSI(=)}>

<赋值表达式> → <一元表达式>{push(一元表达式}  <=> <加法表达式> {ASSI(=)}

**ASSI(=)** **---** 赋值函数

  **⑴ SEND(:= SEM[m],_ ,SEM[m-1] );** 

  **⑵ POP;POP;** 

2.<选择语句> → < IF（表达式）{IF(if)}  语句> {IE(ie)}} < IF（表达式）{IF(if)}  语句 > < ELSE {EL(el} 语句>{IE(ie)}

[![NvhtSA.png](https://s1.ax1x.com/2020/07/04/NvhtSA.png)](https://imgchr.com/i/NvhtSA)

3.

<加法表达式> → <乘法表达式> | <加法表达式 + 乘法表达式>{GEQ(+)} | <加法表达式 - 乘法表达式>{GEQ(-)}

<乘法表达式> → <一元表达式> | <乘法表达式 * 一元表达式>{GEQ(*)} | <乘法表达式 / 一元表达式>{GEQ(/)} | <乘法表达式 % 一元表达式>{GEQ(%)}

<一元表达式> → <后缀表达式> {PUSH(后缀表达式)}

<后缀表达式> → <基本表达式> | <后缀表达式 [ 表达式 ]> | <后缀表达式（）> | <后缀表达式（参数表达式列表）> 

<基本表达式> → <标识符> | <常量> | <字符串> | <（表达式）>